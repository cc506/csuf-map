<!DOCTYPE html>
<html lang="en">

<head>
  <title>CSUF Campus Map</title>

  <meta charset="utf-8" />
  <link rel="shortcut icon" href="/favicon.ico" />

  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <!-- Add references to the Azure Maps Map control JavaScript and CSS files. -->
  <link href="https://atlas.microsoft.com/sdk/javascript/mapcontrol/2/atlas.min.css" rel="stylesheet" />
  <script src="https://atlas.microsoft.com/sdk/javascript/mapcontrol/2/atlas.min.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>

  <!-- Use Threebox https://github.com/jscastro76/threebox to render the 3D models. -->
  <script src="https://unpkg.com/threebox-plugin/dist/threebox.min.js"></script>
  <link href="https://unpkg.com/threebox-plugin/dist/threebox.css" rel="stylesheet" />

  <link href="sample.css" rel="stylesheet" />

  <script>
    var map, datasource, popup;

    function GetMap() {
      map = new atlas.Map("map", {
        center: [-117.8854, 33.8833],
        zoom: 14.7,
        pitch: 60,
        bearing: 130.8,
        showBuildingModels: true,

        // Add authentication details for connecting to Azure Maps.
        authOptions: {
          // Use Azure Active Directory authentication.
          authType: "anonymous",
          clientId: "180aa4ac-3e5c-4e3e-87f3-3783076bbcfb", // Your Azure Maps client id for accessing your Azure Maps account.
          getToken: function (resolve, reject, map) {
            // URL to your authentication service that retrieves an Azure Active Directory Token.
            var tokenServiceUrl =
              "https://samples.azuremaps.com/api/GetAzureMapsToken";

            fetch(tokenServiceUrl)
              .then((r) => r.text())
              .then((token) => resolve(token));
          },

          // Use an Azure Maps key. Get an Azure Maps key at https://azuremaps.com/. NOTE: The primary key should be used as the key.
          authType: "subscriptionKey",
          subscriptionKey: "8Di0A_aTJ5-in5NE_RVwwVQY1SgBI7X0ol9UhlGOFS4",
        },
      });

      // Wait until the map resources are ready
      map.events.add("ready", function () {

        datasource = new atlas.source.DataSource();
        map.sources.add(datasource);

        $(function(){
          $.getJSON('locations.json',function(data){
              $.each(data.locations,function(i,emp){
                datasource.add(new atlas.data.Feature(new atlas.data.Point([emp.center.lng, emp.center.lat]), {
                  content: emp.image,
                  "title": emp.title,
                  "website": "http://www.fullerton.edu/housing/",
                }));
              });
          }).error(function(){
              console.log('error');
          });
        });

        var pointLayer = new atlas.layer.SymbolLayer(datasource);

        map.layers.add([pointLayer], 'points', {
          textOptions: {
            textField: [
                'format',

                //Bold the title property and scale its font size up.
                ['get', 'title'],
                {
                    'text-font': ['literal', ['StandardFont-Bold']],
                    'font-scale': 1.25
                },

                '\n', {},   //Add a new line without any formatting.

                //Scale the font size down of the subtitle property. 
                ['get', 'subtitle'],
                { 'font-scale': 0.75 }
            ]
          }
        });

        //Add click events to the polygon and line layers.
        map.events.add('click', [pointLayer], featureClicked);

        //Create a popup but leave it closed so we can update it and display it later.
        popup = new atlas.Popup();

        // Add controls
        map.controls.add(
          [
            new atlas.control.ZoomControl(),
            new atlas.control.PitchControl(),
            new atlas.control.CompassControl(),
          ],
          {
            position: "top-right",
          }
        );
      });

      // Attach an event to capture when the map is moved
      map.events.add("moveend", function () {
        updateStatus();

      });

      updateStatus();

      let intMap = map.map;
      window.tb = new Threebox(
        intMap,
        intMap.getCanvas().getContext("webgl"),
        {
          defaultLights: true,
          enableSelectingObjects: false, //change this to false to disable 3D objects selection
          enableDraggingObjects: false, //change this to false to disable 3D objects drag & move once selected
          enableRotatingObjects: false, //change this to false to disable 3D objects rotation once selected
          enableTooltips: false, // change this to false to disable default tooltips on fill-extrusion and 3D models
        }
      );

      map.events.add("style.load", function (e) {

        intMap.addLayer({
          id: "custom_layer",
          type: "custom",
          renderingMode: "3d",
          onAdd: function (map, context) {
            initMesh();
          },

          render: function (gl, matrix) {
            tb.update();
          },
        });
      }, 'points');
    }

    let geometry = false;
    let meshes = [];

    var api = {
      count: 212,
      animation: true,
    };

    // Creative Commons License attribution: Windmill animated model by https://sketchfab.com/data3anshow
    // from https://sketchfab.com/3d-models/windmill-animated-6ce5667e8d5c47068ea13196036efd52
    var model = {
      obj: "models/untitled.gltf",
      type: "gltf",
      scale: 160,
    };

    function initMesh() {
      let diff = api.count - tb.world.children.length;
      if (diff == 0) return;

      if (tb.world.children.length > api.count) {
        for (let j = tb.world.children.length - 1; j >= api.count; j--) {
          var obj = tb.world.children[j];
          tb.remove(obj);
        }

        map.repaint = true;
      } else {
        var options = {
          obj: model.obj,
          type: model.type,
          scale: model.scale,
          units: "meters",
          rotation: { x: 90, y: 90, z: 0 },
          anchor: "center",
          cloned: true,
        };
        if (!processing) makeNaive(options, diff);
      }
    }

    let processing = false;

    function makeNaive(options, diff) {
      // Create a data source and add it to the map.
      var dsWindmills = new atlas.source.DataSource();
      map.sources.add(dsWindmills);

      // Load some point data into the data source.
      dsWindmills.importDataFromUrl("map_locs.json").then(() => {
        processing = true;
        let j = 0;
        for (var i = 0; i < diff; i++) {
          tb.loadObj(options, function (model) {
            j++;
            if (!geometry) {
              model.traverse(function (object) {
                if (object.isMesh) meshes.push(object.geometry);
              });
              geometry = true;
            }

            let lng = dsWindmills.getShapeById(j).getCoordinates()[0];
            console.log(dsWindmills.getShapeById(j))
            let lat = dsWindmills.getShapeById(j).getCoordinates()[1];
            let obj = model.setCoords([lng, lat, 0]);

            tb.add(obj);

            if (api.animation) {
              // play default animation, for 5 min. = 300 seconds
              let opt = { animation: 0, duration: 300000 };
              obj.playDefault(opt);
            }

            if (j == diff) {
              processing = false;
            }
          });
        }
        map.repaint = true;
      });
    }

    function updateStatus() {
      var camera = map.getCamera();
      var zoom = camera.zoom;
      var cp = camera.center;
      var pitch = camera.pitch;
      var bearing = camera.bearing;
      document.getElementById("status").innerHTML =
        "Zoom: " +
        zoom.toFixed(1) +
        " / Lon: " +
        cp[0].toFixed(5) +
        " / Lat: " +
        cp[1].toFixed(5) +
        " / Pitch: " +
        pitch.toFixed(1) +
        " / Bearing: " +
        bearing.toFixed(1);
    }

    function featureClicked(e) {
      //Make sure the event occurred on a shape feature.
      if (e.shapes && e.shapes.length > 0) {
        //By default, show the popup where the mouse event occurred.
        var pos = e.position;
        var offset = [0, 0];
        var properties;

        if (e.shapes[0] instanceof atlas.Shape) {
          properties = e.shapes[0].getProperties();

          //If the shape is a point feature, show the popup at the points coordinate.
          if (e.shapes[0].getType() === 'Point') {
            pos = e.shapes[0].getCoordinates();
            offset = [0, -18];
          }
        }

        //Update the content and position of the popup.
        popup.setOptions({
          //Create a table from the properties in the feature.
          content: atlas.PopupTemplate.applyTemplate(properties),
          position: pos,
          pixelOffset: offset
        });

        //Open the popup.
        popup.open(map);
      }
    }
  </script>
</head>

<body onload="GetMap()">
  <div id="map"></div>

  <div style="position:absolute;top:15px;left:15px;background-color:white;padding:10px;border-radius:10px;">
    <input type="text" id="input" value="New York" />
    <input type="button" onClick="search()" value="Search" />
  </div>

  <div id="status"></div>

</body>

</html>